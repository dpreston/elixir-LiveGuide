# Binaries, strings and charlists

## Intro

In "Basic types", we learned a little bit about strings and we used the `is_binary/1` function for checks:

```elixir
string = "hello"
```

```elixir
is_binary(string)
```

In this chapter, we will gain clarity on what exactly binaries are, how they relate to strings, and what single-quoted values, `'like this'`, mean in Elixir. Although strings are one of the most common data types in computer languages, they are subtly complex and are often misunderstood. To understand strings in Elixir, we have to educate ourselves about [Unicode](https://en.wikipedia.org/wiki/Unicode) and character encodings, specifically the [UTF-8](https://en.wikipedia.org/wiki/UTF-8) encoding.

## Unicode and Code Points

In order to facilitate meaningful communication between computers across multiple languages, a standard is required so that the ones and zeros on one machine mean the same thing when they are transmitted to another. The [Unicode Standard](https://unicode.org/standard/standard.html) acts as an official registry of virtually all the characters we know: this includes characters from classical and historical texts, emoji, and formatting and control characters as well.

Unicode organizes all of the characters in its repertoire into code charts, and each character is given a unique numerical index. This numerical index is known as a [Code Point](https://en.wikipedia.org/wiki/Code_point).

In Elixir you can use a `?` in front of a character literal to reveal its code point:

```elixir
?a
```

```elixir
?≈Ç
```

Note that most Unicode code charts will refer to a code point by its hexadecimal (hex) representation, e.g. `97` translates to `0061` in hex, and we can represent any Unicode character in an Elixir string by using the `\uXXXX` notation and the hex representation of its code point number:

```elixir
"\u0061" == "a"
```

```elixir
0x0061 = 97 = ?a
```

The hex representation will also help you look up information about a code point, e.g. [https://codepoints.net/U+0061](https://codepoints.net/U+0061) has a data sheet all about the lower case `a`, a.k.a. code point 97.

## UTF-8 and Encodings

Now that we understand what the Unicode standard is and what code points are, we can finally talk about encodings. Whereas the code point is **what** we store, an encoding deals with **how** we store it: encoding is an implementation. In other words, we need a mechanism to convert the code point numbers into bytes so they can be stored in memory, written to disk, etc.

Elixir uses UTF-8 to encode its strings, which means that code points are encoded as a series of 8-bit bytes. UTF-8 is a **variable width** character encoding that uses one to four bytes to store each code point. It is capable of encoding all valid Unicode code points. Let's see an example:

```elixir
string = "heÃÅllo"
```

```elixir
String.length(string)
```

```elixir
byte_size(string)
```

Although the string above has 5 characters, it uses 6 bytes, as two bytes are used to represent the character `√©`.

> Note: if you are running on Windows, there is a chance your terminal does not use UTF-8 by default. You can change the encoding of your current session by running `chcp 65001` before entering `iex` (`iex.bat`).

Besides defining characters, UTF-8 also provides a notion of graphemes. Graphemes may consist of multiple characters that are often perceived as one. For example, the [woman firefighter emoji](https://emojipedia.org/woman-firefighter/) is represented as the combination of three characters: the woman emoji (üë©), a hidden zero-width joiner, and the fire engine emoji (üöí):

```elixir
String.codepoints("üë©‚Äçüöí")
```

```elixir
String.graphemes("üë©‚Äçüöí")
```

However, Elixir is smart enough to know they are seen as a single character, and therefore the length is still one:

```elixir
String.length("üë©‚Äçüöí")
```

> Note: if you can't see the emoji above in your terminal, you need to make sure your terminal supports emoji and that you are using a font that can render them.

Although these rules may sound complicated, UTF-8 encoded documents are everywhere. This page itself is encoded in UTF-8. The encoding information is given to your browser which then knows how to render all of the bytes, characters, and graphemes accordingly.

If you want to see the exact bytes that a string would be stored in a file, a common trick is to concatenate the null byte `<<0>>` to it:

```elixir
"he≈Ç≈Ço" <> <<0>>
```

Alternatively, you can view a string's binary representation by using [IO.inspect/2](https://hexdocs.pm/elixir/IO.html#inspect/2):

```elixir
IO.inspect("he≈Ç≈Ço", binaries: :as_binaries)
```

We are getting a little bit ahead of ourselves. Let's talk about bitstrings to learn about what exactly the `<<>>` constructor means.

## Bitstrings

Although we have covered code points and UTF-8 encoding, we still need to go a bit deeper into how exactly we store the encoded bytes, and this is where we introduce the **bitstring**. A bitstring is a fundamental data type in Elixir, denoted with the `<<>>` syntax. **A bitstring is a contiguous sequence of bits in memory.**

A complete reference about the binary / bitstring constructor `<<>>` can be found [in the Elixir documentation](https://hexdocs.pm/elixir/Kernel.SpecialForms.html#%3C%3C%3E%3E/1).

By default, 8 bits (i.e. 1 byte) is used to store each number in a bitstring, but you can manually specify the number of bits via a `::n` modifier to denote the size in `n` bits, or you can use the more verbose declaration `::size(n)`:

```elixir
<<42>> == <<42::8>>
```

```elixir
<<3::4>>
```

For example, the decimal number `3` when represented with 4 bits in base 2 would be `0011`, which is equivalent to the values `0`, `0`, `1`, `1`, each stored using 1 bit:

```elixir
<<0::1, 0::1, 1::1, 1::1>> == <<3::4>>
```

Any value that exceeds what can be stored by the number of bits provisioned is truncated:

```elixir
<<1>> == <<257>>
```

Here, 257 in base 2 would be represented as `100000001`, but since we have reserved only 8 bits for its representation (by default), the left-most bit is ignored and the value becomes truncated to `00000001`, or simply `1` in decimal.

## Binaries

**A binary is a bitstring where the number of bits is divisible by 8.** That means that every binary is a bitstring, but not every bitstring is a binary. We can use the `is_bitstring/1` and `is_binary/1` functions to demonstrate this.

```elixir
is_bitstring(<<3::4>>)
```

```elixir
is_binary(<<3::4>>)
```

```elixir
is_bitstring(<<0, 255, 42>>)
```

```elixir
is_binary(<<0, 255, 42>>)
```

```elixir
is_binary(<<42::16>>)
```

We can pattern match on binaries / bitstrings:

```elixir
<<0, 1, x>> = <<0, 1, 2>>
```

```elixir
x
```

```elixir
<<0, 1, x>> = <<0, 1, 2, 3>>
```

Note that unless you explicitly use `::` modifiers, each entry in the binary pattern is expected to match a single byte (exactly 8 bits). If we want to match on a binary of unknown size, we can use the `binary` modifier at the end of the pattern:

```elixir
<<0, 1, x::binary>> = <<0, 1, 2, 3>>
```

```elixir
x
```

There are a couple other modifiers that can be useful when doing pattern matches on binaries. The `binary-size(n)` modifier will match `n` bytes in a binary:

```elixir
<<head::binary-size(2), rest::binary>> = <<0, 1, 2, 3>>
```

```elixir
head
```

```elixir
rest
```

**A string is a UTF-8 encoded binary**, where the code point for each character is encoded using 1 to 4 bytes. Thus every string is a binary, but due to the UTF-8 standard encoding rules, not every binary is a valid string.

```elixir
is_binary("hello")
```

```elixir
is_binary(<<239, 191, 19>>)
```

```elixir
String.valid?(<<239, 191, 19>>)
```

The string concatenation operator `<>` is actually a binary concatenation operator:

```elixir
"a" <> "ha"
```

```elixir
<<0, 1>> <> <<2, 3>>
```

Given that strings are binaries, we can also pattern match on strings:

```elixir
<<head, rest::binary>> = "banana"
```

```elixir
head == ?b
```

```elixir
rest
```

However, remember that binary pattern matching works on *bytes*, so matching on the string like "√ºber" with multibyte characters won't match on the _character_, it will match on the _first byte of that character_:

```elixir
"√º" <> <<0>>
```

```elixir
<<x, rest::binary>> = "√ºber"
```

```elixir
x == ?√º
```

```elixir
rest
```

Above, `x` matched on only the first byte of the multibyte `√º` character.

Therefore, when pattern matching on strings, it is important to use the `utf8` modifier:

```elixir
<<x::utf8, rest::binary>> = "√ºber"
```

```elixir
x == ?√º
```

```elixir
rest
```

## Charlists

Our tour of our bitstrings, binaries, and strings is nearly complete, but we have one more data type to explain: the charlist.

**A charlist is a list of integers where all the integers are valid code points.** In practice, you will not come across them often, only in specific scenarios such as interfacing with older Erlang libraries that do not accept binaries as arguments.

Whereas double-quotes creates strings, single-quotes create charlist literals:

```elixir
'hello'
```

```elixir
[?h, ?e, ?l, ?l, ?o]
```

The key takeaway is that `"hello"` is not the same as `'hello'`. Generally speaking, **double-quotes must always be used to represent strings in Elixir**. In any case, let's learn how charlists work.

Instead of containing bytes, a charlist contains integer code points. However, the list is only printed in single-quotes if all code points are within the ASCII range:

```elixir
'he≈Ç≈Ço'
```

```elixir
is_list('he≈Ç≈Ço')
```

Interpreting integers as code points may lead to some surprising behavior. For example, if you are storing a list of integers that happen to range between 0 and 127, by default IEx will interpret this as a charlist and it will display the corresponding ASCII characters.

```elixir
heartbeats_per_minute = [99, 97, 116]
```

You can convert a charlist to a string and back by using the `to_string/1` and `to_charlist/1` functions:

```elixir
to_charlist("he≈Ç≈Ço")
```

```elixir
to_string('he≈Ç≈Ço')
```

```elixir
to_string(:hello)
```

```elixir
to_string(1)
```

Note that those functions are polymorphic - not only do they convert charlists to strings, they also operate on integers, atoms, and so on.

String (binary) concatenation uses the `<>` operator but charlists, being lists, use the list concatenation operator `++`:

```elixir
'this ' <> 'fails'
```

```elixir
'this ' ++ 'works'
```

```elixir
"he" ++ "llo"
```

```elixir
"he" <> "llo"
```

With binaries, strings, and charlists out of the way, it is time to talk about key-value data structures.
